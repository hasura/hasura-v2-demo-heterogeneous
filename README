# -*- mode: org; -*-

#+STARTUP: indent

* What

* Why

* How

* Part A:  At the Command Line

** Step 1:  Create a new directory.

Create a directory to work in and move to it.

#+begin_src bash :exports code :session scratch :results none
  mkdir -p scratch
  cd scratch
#+end_src

- What did this do? ::
  This step 

** Step 2:  Create a PostgreSQL initialization directory.

Create a directory to mount into the PostgreSQL container in order to
initialize the database.

#+begin_src bash :exports code :session scratch :results none
  mkdir -p initdb.d-postgres
#+end_src

- What did this do? ::
  This step 

** Step 3:  Download the PostgresSQL initialization files.

Download PostgreSQL initialization scripts into its initialization
directory.

#+begin_src bash :exports code :session scratch :results none
  wget -O initdb.d-postgres/03_chinook_database.sql https://raw.githubusercontent.com/hasura/hasura-v2-demo-heterogeneous/main/initdb.d-postgres/03_chinook_database.sql?token=GHSAT0AAAAAACU4IFOYXZX42LRNWXHFUIFAZVJK5YQ
  wget -O initdb.d-postgres/04_chinook_ddl.sql https://raw.githubusercontent.com/hasura/hasura-v2-demo-heterogeneous/main/initdb.d-postgres/04_chinook_ddl.sql?token=GHSAT0AAAAAACU4IFOZRCCNAD67ALMMVVWSZVJK5ZQ
  wget -O initdb.d-postgres/05_chinook_dml.sql https://raw.githubusercontent.com/hasura/hasura-v2-demo-heterogeneous/main/initdb.d-postgres/05_chinook_dml.sql?token=GHSAT0AAAAAACU4IFOZ2CYRGAADVAHVUCOYZVJK53A
#+end_src

- What did this do? ::
  This step 

** Step 4:  Scaffold the Docker Compose file.

Use a code editor to start the Docker Compose file with its preamble.

#+begin_src yaml
version: '3.1'
services:
#+end_src

Alternatively, add to the file from the command line.

#+begin_src bash :exports code :session scratch :results none
cat <<'EOF' > docker-compose.yaml
version: '3.1'
services:
EOF
#+end_src

- What did this do? ::
  This step 

** Step 5:  Add the ~postgres~ service.

Use a code editor to add a stanza for the ~postgres~ service.

#+begin_src yaml
  postgres:
    image: postgres:16          # Use a modern version of PostgreSQL.
    ports:
      - ${PGPORT}:5432          # Expose it on a port taken from an environment variable.
    environment:                # Set its superuser username and password.
      POSTGRES_PASSWORD: postgres
      POSTGRES_USER: postgres
    volumes:                    # Initialize from the contents of the initialization directory.
      - ./initdb.d-postgres:/docker-entrypoint-initdb.d:ro
    healthcheck:                # Use a sensible healthcheck.
      test: psql -U postgres -d chinook -c "select count(*) from \"Artist\""
#+end_src

Alternatively, add to the file from the command line.

#+begin_src bash :exports code :session scratch :results none
cat <<'EOF' >> docker-compose.yaml
  postgres:
    image: postgres:16          # Use a modern version of PostgreSQL.
    ports:
      - ${PGPORT}:5432          # Expose it on a port taken from an environment variable.
    environment:                # Set its superuser username and password.
      POSTGRES_PASSWORD: postgres
      POSTGRES_USER: postgres
    volumes:                    # Initialize from the contents of the initialization directory.
      - ./initdb.d-postgres:/docker-entrypoint-initdb.d:ro
    healthcheck:                # Use a sensible healthcheck.
      test: psql -U postgres -d chinook -c "select count(*) from \"Artist\""
EOF
#+end_src

- What did this do? ::
  This step 

** Step 6:  Set environment variables.

Set environment variables to be used by Docker Compose but which
should not be hard-coded into the Docker Compose file.

#+begin_src bash :exports code :session scratch :results none
  export PGPORT=5433		# or your own port
  export PGUSER=postgres
  export PGPASSWORD=postgres
  export PGDATABASE=chinook
  export PGHOST=localhost
#+end_src

- What did this do? ::
  This step 

** Step 7:  Test the PostgreSQL service.

Use Docker Compose to start the ~postgres~ service.

#+begin_src bash :exports code :session scratch :results none
  docker compose up -d postgres
#+end_src

Run a query against the database to verify that it has been
initialized.

#+begin_src bash :exports code :session scratch :results output
  docker exec scratch-postgres-1 psql -U postgres -d chinook -c "select count(*) from \"Track\""
#+end_src

#+RESULTS:
: count 
: -------
:   3503
: (1 row)

- What did this do? ::
  This step 

** Step 8:  Create a MongoDB initialization directory.

Create a directory to mount into the MongoDB container in order to
initialize the database.

#+begin_src bash :exports code :session scratch :results none
  mkdir -p initdb.d-mongo
#+end_src

- What did this do? ::
  This step 

** Step 9:  Download the MongoDB initialization files.

Download Mongo DB initializaiton files into its initialization
directory.

#+begin_src bash :exports code :session scratch :results none
  wget -O initdb.d-mongo/01_import_data.sh https://raw.githubusercontent.com/hasura/hasura-v2-demo-heterogeneous/main/initdb.d-mongo/01_import_data.sh?token=GHSAT0AAAAAACU4IFOZPD2F2WPQSJYCFR6OZVJMS2Q
  wget -O initdb.d-mongo/postgres.Album.json https://raw.githubusercontent.com/hasura/hasura-v2-demo-heterogeneous/main/initdb.d-mongo/postgres.Album.json?token=GHSAT0AAAAAACU4IFOZEMZRK75GBGH2526QZVJMS4A
  wget -O initdb.d-mongo/postgres.Artist.json https://raw.githubusercontent.com/hasura/hasura-v2-demo-heterogeneous/main/initdb.d-mongo/postgres.Artist.json?token=GHSAT0AAAAAACU4IFOZIHWEZHDLYAEWVKW4ZVJMS5A
  wget -O initdb.d-mongo/postgres.Track.json https://raw.githubusercontent.com/hasura/hasura-v2-demo-heterogeneous/main/initdb.d-mongo/postgres.Track.json?token=GHSAT0AAAAAACU4IFOYJBMR6SRKNKXAOVWMZVJMW4A
#+end_src

- What did this do? ::
  This step 

** Step 10:  Add the ~mongo~ service.

Use a code editor to add a stanza for the ~mongo~ service.

#+begin_src yaml
  mongo:
    image: mongo:6              # Use a modern version of MongoDB.
    ports:
      - ${MGPORT}:27017         # Expose it on a port taken from an environment variable.
    environment:                # Set its superuser username and password.
      MONGO_INITDB_ROOT_PASSWORD: mongo
      MONGO_INITDB_ROOT_USERNAME: mongo
    volumes:                    # Initialize from the contents of the initialization directory.
      - ./initdb.d-mongo:/docker-entrypoint-initdb.d:ro
    depends_on:                 # Wait until postgres starts up first.
      postgres:
        condition: service_healthy
#+end_src

Alternatively, add to the file from the command line.

#+begin_src bash :exports code :session scratch :results none
cat <<'EOF' >> docker-compose.yaml
  mongo:
    image: mongo:6              # Use a modern version of MongoDB.
    ports:
      - ${MGPORT}:27017         # Expose it on a port taken from an environment variable.
    environment:                # Set its superuser username and password.
      MONGO_INITDB_ROOT_PASSWORD: mongo
      MONGO_INITDB_ROOT_USERNAME: mongo
    volumes:                    # Initialize from the contents of the initialization directory.
      - ./initdb.d-mongo:/docker-entrypoint-initdb.d:ro
    depends_on:                 # Wait until postgres starts up first.
      postgres:
        condition: service_healthy
EOF
#+end_src

- What did this do? ::
  This step 

** Step 11:  Set environment variables.

Set environment variables to be used by Docker Compose but which
should not be hard-coded into the Docker Compose file.

#+begin_src bash :exports code :session scratch :results none
  export MGPORT=27018		# or your own port
#+end_src

- What did this do? ::
  This step 

** Step 12:  Test the MongoDB service.

User Docker Compose to start the ~mongo~ service.

#+begin_src bash :exports code :session scratch :results none
  docker compose up -d mongo
#+end_src

Run a query against the database to verify that it has been
initialized.

#+begin_src bash :exports code :session scratch :results output
  docker exec scratch-mongo-1 mongosh --quiet -u mongo -p mongo --eval "db.postgres.Album.findOne()" admin 
#+end_src

#+RESULTS:
: {
:   _id: ObjectId('6637f6cc7cda30b626bb1d07'),
:   AlbumId: 1,
:   Title: 'For Those About To Rock We Salute You',
:   ArtistId: 1
: }

- What did this do? ::
  This step 

** Step 13:  Add the ~mongo_data_connector~ service.

Use a code editor to add a stanza for the ~mongo-data-connector~
service.

#+begin_src yaml
  mongo_data_connector:         # Start the connector agent.
    image: hasura/mongo-data-connector:v2.38.0
    depends_on:                 # Wait until mongo starts up first.
      - mongo
#+end_src

Alternatively, add to the file from the command line.

#+begin_src bash :exports code :session scratch :results none
cat <<'EOF' >> docker-compose.yaml
  mongo_data_connector:         # Start the connector agent.
    image: hasura/mongo-data-connector:v2.38.0
    depends_on:                 # Wait until mongo starts up first.
      - mongo
EOF
#+end_src

- What did this do? ::
  This step 

** Step 14:  Add the ~redis~ service.

Use a code editor to add a stanza for the ~redis~ service.

#+begin_src yaml
  redis:
    image: redis:latest
#+end_src

Alternatively, add to the file from the command line.

#+begin_src bash :exports code :session scratch :results none
cat <<'EOF' >> docker-compose.yaml
  redis:
    image: redis:latest
EOF
#+end_src

- What did this do? ::
  This step 

** Step 15:  Add Hasura.

Use a code editor to add a stanza for the ~hasura~ service.

#+begin_src yaml
  hasura:                       # Start Hasura.
    image: hasura/graphql-engine:v2.40.0
    depends_on:                 # Wait until the connector agent starts up first.
      - mongo_data_connector
    ports:                      # Expose it on a port taken from an environment variable
      - ${HGPORT}:8080
    healthcheck:                # Use a sensible healthcheck.
      test: curl -s http://localhost:8080/healthz
      start_period: 60s
    environment:                # Configure Hasura.
      HASURA_GRAPHQL_ADMIN_SECRET: hasura # Hasura EE requires an admin secret.
      HASURA_GRAPHQL_DEV_MODE: true       # We require dev mode.
      HASURA_GRAPHQL_EE_LICENSE_KEY: ${HASURA_GRAPHQL_EE_LICENSE_KEY} # Hasura EE requires a license key.
      HASURA_GRAPHQL_ENABLE_CONSOLE: true # We require Hasura Console.
      HASURA_GRAPHQL_MAX_CACHE_SIZE: 200  # Set Redis cache size.
      HASURA_GRAPHQL_METADATA_DATABASE_URL: postgres://postgres:postgres@postgres/metadata # Hasura requires a PostgreSQL DB for metadata.
      HASURA_GRAPHQL_METADATA_DEFAULTS: '{"backend_configs":{"dataconnector":{"Mongo":{"uri":"http://mongo_data_connector:3000"}}}}' # Tell Hasura about the connector agent.
      HASURA_GRAPHQL_RATE_LIMIT_REDIS_URL: redis://redis:6379 # Set the Redis URL for rate-limiting.
      HASURA_GRAPHQL_REDIS_URL: redis://redis:6379            # Use the same Redis URL for caching.
      POSTGRES_URL: postgres://postgres:postgres@postgres/chinook # Set a database URL environment variable.
#+end_src

Alternatively, add to the file from the command line.

#+begin_src bash :exports code :session scratch :results none
cat <<'EOF' >> docker-compose.yaml
  hasura:                       # Start Hasura.
    image: hasura/graphql-engine:v2.40.0
    depends_on:                 # Wait until the connector agent starts up first.
      - mongo_data_connector
    ports:                      # Expose it on a port taken from an environment variable
      - ${HGPORT}:8080
    healthcheck:                # Use a sensible healthcheck.
      test: curl -s http://localhost:8080/healthz
      start_period: 60s
    environment:                # Configure Hasura.
      HASURA_GRAPHQL_ADMIN_SECRET: hasura # Hasura EE requires an admin secret.
      HASURA_GRAPHQL_DEV_MODE: true       # We require dev mode.
      HASURA_GRAPHQL_EE_LICENSE_KEY: ${HASURA_GRAPHQL_EE_LICENSE_KEY} # Hasura EE requires a license key.
      HASURA_GRAPHQL_ENABLE_CONSOLE: true # We require Hasura Console.
      HASURA_GRAPHQL_MAX_CACHE_SIZE: 200  # Set Redis cache size.
      HASURA_GRAPHQL_METADATA_DATABASE_URL: postgres://postgres:postgres@postgres/metadata # Hasura requires a PostgreSQL DB for metadata.
      HASURA_GRAPHQL_METADATA_DEFAULTS: '{"backend_configs":{"dataconnector":{"Mongo":{"uri":"http://mongo_data_connector:3000"}}}}' # Tell Hasura about the connector agent.
      HASURA_GRAPHQL_RATE_LIMIT_REDIS_URL: redis://redis:6379 # Set the Redis URL for rate-limiting.
      HASURA_GRAPHQL_REDIS_URL: redis://redis:6379            # Use the same Redis URL for caching.
      POSTGRES_URL: postgres://postgres:postgres@postgres/chinook # Set a database URL environment variable.
EOF
#+end_src

- What did this do? ::
  This step 

** Step 16:  Set environment variables.

Set environment variables to be used by Docker Compose but which
should not be hard-coded into the Docker Compose file

#+begin_src bash :exports code :session scratch :results none
  export HASURA_GRAPHQL_EE_LICENSE_KEY=<your EE license key>
  export HGPORT=8081		# or your own port
#+end_src

- What did this do? ::
  This step 

** Step 17:  Start the ~mongo_data_connector~, ~redis~ and ~hasura~ services.

Use Docker Compose to start the ~mongo_data_connector~, ~redis~ and
~hasura~ services.

#+begin_src bash :exports code :session scratch :results none
  docker compose up -d mongo_data_connector redis hasura
#+end_src

- What did this do? ::
  This step 

** Step 18:  Open the Hasura Console and log in.

Open a browser to the Hasura Console.

#+begin_src bash :exports code :session scratch :results none
  xdg-open http://localhost:8081	# or your own port
#+end_src

- What did this do? ::
  This step 

* Part B:  In Hasura Console
